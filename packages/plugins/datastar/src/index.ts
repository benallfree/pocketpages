import type { PagesRequest, PluginFactory } from 'pocketpages'
import loader from './loader.html'

// This is auto-generated by Datastar. DO NOT EDIT.

const DatastarKey = 'datastar'
// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.
const DefaultSseRetryDuration = 1000 // milliseconds

const SelectorDatalineLiteral = 'selector '
const ModeDatalineLiteral = 'mode '
const ElementsDatalineLiteral = 'elements '
const UseViewTransitionDatalineLiteral = 'useViewTransition '
const SignalsDatalineLiteral = 'signals '
const OnlyIfMissingDatalineLiteral = 'onlyIfMissing '

// Should elements be patched using the ViewTransition API?
const DefaultElementsUseViewTransitions = false
// Should a given set of signals patch if they are missing?
const DefaultPatchSignalsOnlyIfMissing = false

// The mode in which an element is patched into the DOM.
enum ElementPatchMode {
  Default = 'outer',
  Outer = 'outer',
  Inner = 'inner',
  Remove = 'remove',
  Replace = 'replace',
  Prepend = 'prepend',
  Append = 'append',
  Before = 'before',
  After = 'after',
}

enum EventType {
  PatchElements = 'datastar-patch-elements',
  PatchSignals = 'datastar-patch-signals',
}

type DurationInMilliseconds = number

type PatchElementsOptions = {
  selector: string
  mode: ElementPatchMode
  useViewTransition: boolean
  eventId: string
  retryDuration: DurationInMilliseconds
}

type PatchSignalsOptions = {
  eventId: string
  retryDuration: DurationInMilliseconds
  onlyIfMissing: boolean
}

type ExecuteScriptOptions = {
  eventId: string
  autoRemove: boolean | null
  attributes: string[]
  retryDuration: DurationInMilliseconds
}

type DispatchCustomEventOptions = {
  eventId: string
  retryDuration: DurationInMilliseconds
  selector: string
  bubbles: boolean
  cancelable: boolean
  composed: boolean
}

type ReadSignalsOptions = {
  // Options for reading signals from request
}

const datastarPluginFactory: PluginFactory = (config) => {
  const { dbg } = config

  return {
    name: 'datastar',
    onExtendContextApi: ({ api }) => {
      function send(
        eventType: EventType,
        dataLines: string[],
        options?: {
          eventId?: string
          retryDuration?: DurationInMilliseconds
        }
      ) {
        dbg('send', { eventType, dataLines, options })
        api.response.header('Content-Type', 'text/event-stream')
        api.response.header('Cache-Control', 'no-cache')
        api.response.header('Connection', 'keep-alive')
        api.echo(`event: ${eventType}\n`)
        if (options?.eventId) api.echo(`id: ${options?.eventId}\n`)
        if (options?.retryDuration)
          api.echo(`retry: ${options?.retryDuration}\n`)
        dataLines.forEach((dataLine) => api.echo(`data: ${dataLine}\n`))
        api.echo('\n')
      }
      api.datastar = {
        scripts() {
          return loader
        },
        realtime: {
          patchSignals: (
            signals: string,
            options?: Partial<PatchSignalsOptions>
          ) => {
            api.realtime.send(
              'datastar',
              api.stringify({
                type: EventType.PatchSignals,
                el: null,
                argsRaw: {
                  signals,
                  ...options,
                },
              })
            )
          },
          patchElements: (
            elements: string,
            options?: Partial<PatchElementsOptions>
          ) => {
            api.realtime.send(
              'datastar',
              api.stringify({
                type: EventType.PatchElements,
                el: null,
                argsRaw: {
                  elements,
                  ...options,
                },
              })
            )
          },
        },
        patchElements: (
          elements: string,
          options?: Partial<PatchElementsOptions>
        ) => {
          const opts: PatchElementsOptions = {
            eventId: '',
            retryDuration: DefaultSseRetryDuration,
            selector: '',
            mode: ElementPatchMode.Default,
            useViewTransition: DefaultElementsUseViewTransitions,
            ...options,
          }

          const dataLines: string[] = []

          if (opts.selector) {
            dataLines.push(SelectorDatalineLiteral + opts.selector)
          }
          if (opts.mode !== ElementPatchMode.Default) {
            dataLines.push(ModeDatalineLiteral + opts.mode)
          }
          if (opts.useViewTransition) {
            dataLines.push(UseViewTransitionDatalineLiteral + 'true')
          }

          if (elements) {
            const parts = elements.split('\n')
            for (const part of parts) {
              dataLines.push(ElementsDatalineLiteral + part)
            }
          }

          send(EventType.PatchElements, dataLines, {
            eventId: opts.eventId,
            retryDuration: opts.retryDuration,
          })
        },
        patchSignals: (
          signalsContents: string,
          options?: Partial<PatchSignalsOptions>
        ) => {
          const opts: PatchSignalsOptions = {
            eventId: '',
            retryDuration: DefaultSseRetryDuration,
            onlyIfMissing: DefaultPatchSignalsOnlyIfMissing,
            ...options,
          }

          const dataLines: string[] = []

          if (opts.onlyIfMissing) {
            dataLines.push(
              OnlyIfMissingDatalineLiteral + opts.onlyIfMissing.toString()
            )
          }

          if (signalsContents) {
            const lines = signalsContents.split('\n')
            for (const line of lines) {
              dataLines.push(SignalsDatalineLiteral + line)
            }
          }

          send(EventType.PatchSignals, dataLines, {
            eventId: opts.eventId,
            retryDuration: opts.retryDuration,
          })
        },
        executeScript: (
          scriptContents: string,
          options?: Partial<ExecuteScriptOptions>
        ) => {
          const opts: ExecuteScriptOptions = {
            eventId: '',
            autoRemove: null,
            attributes: [],
            retryDuration: DefaultSseRetryDuration,
            ...options,
          }

          // Build the script element
          let scriptElement = '<script'

          // Add attributes
          for (const attribute of opts.attributes) {
            scriptElement += ' ' + attribute
          }

          // Add data-datastar-autoremove attribute if needed
          if (opts.autoRemove === null || opts.autoRemove) {
            scriptElement += ` data-effect="el.remove()"`
          }

          scriptElement += '>'
          scriptElement += scriptContents
          scriptElement += '</script>'

          // Use patchElements to send the script
          api.datastar.patchElements(scriptElement, {
            selector: 'body',
            mode: ElementPatchMode.Append,
            eventId: opts.eventId,
            retryDuration: opts.retryDuration,
          })
        },
        consoleLog: (msg: string, options?: Partial<ExecuteScriptOptions>) => {
          const call = `console.log(${JSON.stringify(msg)})`
          api.datastar.executeScript(call, options)
        },
        consoleError: (
          err: Error | string,
          options?: Partial<ExecuteScriptOptions>
        ) => {
          const errorMsg = typeof err === 'string' ? err : err.message
          const call = `console.error(${JSON.stringify(errorMsg)})`
          api.datastar.executeScript(call, options)
        },
        redirect: (url: string, options?: Partial<ExecuteScriptOptions>) => {
          const js = `setTimeout(() => window.location.href = ${JSON.stringify(url)})`
          api.datastar.executeScript(js, options)
        },
        dispatchCustomEvent: (
          eventName: string,
          detail: any,
          options?: Partial<DispatchCustomEventOptions>
        ) => {
          if (!eventName) {
            throw new Error('eventName is required')
          }

          const detailsJSON = JSON.stringify(detail)
          const opts: DispatchCustomEventOptions = {
            eventId: '',
            retryDuration: DefaultSseRetryDuration,
            selector: 'document',
            bubbles: true,
            cancelable: true,
            composed: true,
            ...options,
          }

          const elementsJS =
            opts.selector === 'document'
              ? '[document]'
              : `document.querySelectorAll(${JSON.stringify(opts.selector)})`

          const js = `
const elements = ${elementsJS}

const event = new CustomEvent(${JSON.stringify(eventName)}, {
  bubbles: ${opts.bubbles},
  cancelable: ${opts.cancelable},
  composed: ${opts.composed},
  detail: ${detailsJSON},
});

elements.forEach((element) => {
  element.dispatchEvent(event);
});
          `

          const executeOptions: Partial<ExecuteScriptOptions> = {}
          if (opts.eventId) {
            executeOptions.eventId = opts.eventId
          }
          if (opts.retryDuration) {
            executeOptions.retryDuration = opts.retryDuration
          }

          api.datastar.executeScript(js, executeOptions)
        },
        replaceURL: (url: string, options?: Partial<ExecuteScriptOptions>) => {
          const js = `window.history.replaceState({}, "", ${JSON.stringify(url)})`
          api.datastar.executeScript(js, options)
        },
        prefetch: (urls: string[], options?: Partial<ExecuteScriptOptions>) => {
          const wrappedURLs = urls.map((url) => JSON.stringify(url))
          const script = `
{
  "prefetch": [
    {
      "source": "list",
      "urls": [
        ${wrappedURLs.join(',\n        ')}
      ]
    }
  ]
}
          `
          api.datastar.executeScript(script, {
            autoRemove: false,
            attributes: ['type="speculationrules"'],
            ...options,
          })
        },
        readSignals: <T = any>(request: PagesRequest, target: T): T => {
          let dsInput: string = ''

          if (request.method === 'GET') {
            // Access query parameters from params (which includes query string parameters)
            dsInput = api.stringify(request.url.query[DatastarKey] || {})
          } else {
            // Get body as string
            const body = request.body()
            dsInput = typeof body === 'string' ? body : JSON.stringify(body)
          }

          if (!dsInput) {
            return target
          }

          try {
            const parsed = JSON.parse(dsInput)
            // Use Object.assign to merge into the target object
            return Object.assign(target as object, parsed) as T
          } catch (error) {
            throw new Error(`Failed to unmarshal signals: ${error}`)
          }
        },
      }
    },
  }
}

export default datastarPluginFactory
